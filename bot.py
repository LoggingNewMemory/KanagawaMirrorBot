# -*- coding: utf-8 -*-
"""Bot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/LoggingNewMemory/MirrorBot/blob/main/Bot.ipynb

**Google Colab Mirrorbot** <br />
By: Kanagawa Yamada
"""

# Mirror Bot for Google Colab with Download Speed Indicator and Preserved Filenames
# Install required packages
!pip install requests beautifulsoup4 pyrogram tgcrypto

import os
import requests
import asyncio
import time
from urllib.parse import urlparse, unquote
from pathlib import Path
import zipfile
import tarfile
from google.colab import drive, files
from IPython.display import display, HTML
import shutil
import re

class MirrorBot:
    def __init__(self):
        self.download_dir = "/content/downloads"
        self.drive_dir = "/content/drive/MyDrive/MirrorBot"
        self.mount_drive()
        self.setup_directories()

    def mount_drive(self):
        """Mount Google Drive"""
        try:
            drive.mount('/content/drive')
            print("âœ… Google Drive mounted successfully")
        except Exception as e:
            print(f"âŒ Error mounting drive: {e}")

    def setup_directories(self):
        """Create necessary directories"""
        os.makedirs(self.download_dir, exist_ok=True)
        os.makedirs(self.drive_dir, exist_ok=True)
        print(f"ğŸ“ Directories created: {self.download_dir}, {self.drive_dir}")

    def download_sourceforge(self, sf_url, custom_name=None):
        """
        Download a file from SourceForge by converting the project link
        to a direct download URL and deferring to download_file().
        """
        # Parse project and filepath out of the SourceForge URL
        m = re.match(r".*projects/([^/]+)/files/(.*)/download", sf_url)
        if not m:
            print(f"âŒ Invalid SourceForge URL: {sf_url}")
            return None
        project, filepath = m.groups()

        # Build the direct master.dl URL
        direct_url = (
            f"https://master.dl.sourceforge.net/project/"
            f"{project}/{filepath}?viasf=1"
        )
        return self.download_file(direct_url, custom_name)

    def download_file(self, url, custom_name=None):
        """Download file with speed/ETA and preserved filename"""
        # Auto-route SourceForge â€œ/downloadâ€ links
        if 'sourceforge.net/projects' in url and url.endswith('/download'):
            return self.download_sourceforge(url, custom_name)

        try:
            print(f"ğŸ”„ Starting download: {url}")
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'
            }
            response = requests.get(url, headers=headers, stream=True)
            response.raise_for_status()

            # Determine filename
            if custom_name:
                filename = custom_name
            else:
                filename = self.get_filename_from_url(url, response)
            filename = self.sanitize_filename(filename)

            filepath = os.path.join(self.download_dir, filename)
            # Handle duplicates...
            if os.path.exists(filepath):
                base, ext = os.path.splitext(filename)
                counter = 1
                while os.path.exists(filepath):
                    filename = f"{base}_{counter}{ext}"
                    filepath = os.path.join(self.download_dir, filename)
                    counter += 1

            print(f"ğŸ“ Saving as: {filename}")
            total_size = int(response.headers.get('content-length', 0))
            downloaded = 0
            start_time = time.time()
            last_time = start_time
            last_downloaded = 0
            speed_samples = []
            max_samples = 10

            with open(filepath, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if not chunk:
                        continue
                    f.write(chunk)
                    downloaded += len(chunk)

                    now = time.time()
                    elapsed = now - last_time
                    if elapsed >= 0.5:
                        delta = downloaded - last_downloaded
                        curr_speed = delta / elapsed if elapsed > 0 else 0
                        speed_samples.append(curr_speed)
                        if len(speed_samples) > max_samples:
                            speed_samples.pop(0)

                        avg_speed = sum(speed_samples) / len(speed_samples)
                        if total_size:
                            pct = downloaded / total_size * 100
                            eta = self.estimate_time_remaining(
                                downloaded, total_size, avg_speed
                            )
                            print(
                                f"\rğŸ“¥ {pct:.1f}% | {self.format_speed(avg_speed)}"
                                f" | ETA: {eta} | "
                                f"{self.format_size(downloaded)}/{self.format_size(total_size)}",
                                end='', flush=True
                            )
                        else:
                            print(
                                f"\rğŸ“¥ {self.format_speed(avg_speed)} | "
                                f"{self.format_size(downloaded)} downloaded",
                                end='', flush=True
                            )

                        last_time = now
                        last_downloaded = downloaded

            total_time = time.time() - start_time
            avg_speed = downloaded / total_time if total_time > 0 else 0
            print(f"\nâœ… Downloaded: {filename}")
            print(
                f"ğŸ“Š Size: {self.format_size(downloaded)} | "
                f"Time: {total_time:.1f}s | Avg Speed: {self.format_speed(avg_speed)}"
            )
            return filepath

        except Exception as e:
            print(f"\nâŒ Download failed: {e}")
            return None

    def format_size(self, bytes):
        """Format file size"""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if bytes < 1024:
                return f"{bytes:.1f} {unit}"
            bytes /= 1024
        return f"{bytes:.1f} TB"

    def extract_archive(self, filepath):
        """Extract compressed files"""
        try:
            extract_dir = os.path.splitext(filepath)[0]
            os.makedirs(extract_dir, exist_ok=True)

            print(f"ğŸ“¦ Extracting archive...")

            if filepath.endswith(('.zip', '.jar')):
                with zipfile.ZipFile(filepath, 'r') as zip_ref:
                    zip_ref.extractall(extract_dir)
            elif filepath.endswith(('.tar', '.tar.gz', '.tgz', '.gz')):
                # Handle .gz files (including .img.gz)
                if filepath.endswith('.gz') and not filepath.endswith(('.tar.gz', '.tgz')):
                    # Single file gzip
                    import gzip
                    output_file = filepath[:-3]  # Remove .gz extension
                    with gzip.open(filepath, 'rb') as gz_file:
                        with open(output_file, 'wb') as out_file:
                            shutil.copyfileobj(gz_file, out_file)
                    print(f"âœ… Extracted to: {output_file}")
                    return output_file
                else:
                    # Tar archives
                    with tarfile.open(filepath, 'r:*') as tar_ref:
                        tar_ref.extractall(extract_dir)
            else:
                print("âš ï¸ Not a supported archive format")
                return filepath

            print(f"âœ… Extracted to: {extract_dir}")
            return extract_dir

        except Exception as e:
            print(f"âŒ Extraction failed: {e}")
            return filepath

    def move_to_drive(self, filepath):
        """Move downloaded file to Google Drive"""
        try:
            filename = os.path.basename(filepath)
            drive_path = os.path.join(self.drive_dir, filename)

            print(f"â˜ï¸ Moving to Google Drive...")

            if os.path.isdir(filepath):
                shutil.copytree(filepath, drive_path, dirs_exist_ok=True)
            else:
                shutil.copy2(filepath, drive_path)

            print(f"âœ… Moved to Drive: {drive_path}")
            return drive_path

        except Exception as e:
            print(f"âŒ Failed to move to Drive: {e}")
            return None

    def list_downloads(self):
        """List all downloaded files"""
        print("\nğŸ“‹ Downloaded Files:")
        print("-" * 60)

        total_files = 0
        total_size = 0

        for root, dirs, files in os.walk(self.download_dir):
            level = root.replace(self.download_dir, '').count(os.sep)
            indent = ' ' * 2 * level
            if level == 0 and files:
                print(f"{indent}ğŸ“ {os.path.basename(root) or 'downloads'}/")
            elif level > 0:
                print(f"{indent}ğŸ“ {os.path.basename(root)}/")

            subindent = ' ' * 2 * (level + 1)
            for file in files:
                filepath = os.path.join(root, file)
                size = os.path.getsize(filepath)
                total_files += 1
                total_size += size
                print(f"{subindent}ğŸ“„ {file} ({self.format_size(size)})")

        print("-" * 60)
        print(f"ğŸ“Š Total: {total_files} files, {self.format_size(total_size)}")

    def clear_downloads(self):
        """Clear download directory"""
        try:
            shutil.rmtree(self.download_dir)
            os.makedirs(self.download_dir, exist_ok=True)
            print("ğŸ—‘ï¸ Downloads cleared")
        except Exception as e:
            print(f"âŒ Error clearing downloads: {e}")

    def mirror(self, url, extract=False, move_to_drive=True, custom_name=None):
        """Main mirror function"""
        print(f"ğŸš€ Mirror Bot Starting...")
        print(f"ğŸ“‚ Download directory: {self.download_dir}")
        print(f"â˜ï¸ Drive directory: {self.drive_dir}")
        print("=" * 60)

        # Download file
        filepath = self.download_file(url, custom_name)
        if not filepath:
            return None

        # Extract if requested and it's an archive
        if extract:
            filepath = self.extract_archive(filepath)

        # Move to Google Drive if requested
        if move_to_drive:
            drive_path = self.move_to_drive(filepath)
            if drive_path:
                print(f"âœ¨ Mirror completed! File saved to Drive")
                return drive_path

        print(f"âœ¨ Mirror completed! File saved locally")
        return filepath

mirror_file("https://sourceforge.net/projects/andyyan-gsi/files/lineage-22-light/lineage-22.2-20250522-UNOFFICIAL-gsi_arm64_gN-signed.img.gz/download")